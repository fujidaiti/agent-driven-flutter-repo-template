# Guidelines for Flutter App Development

Flutterアプリの開発における普遍的な原則とベストプラクティスをまとめたドキュメントです。

## Core Principle

### 常にスコープを最小に保つ

変数、クラス、関数、定数など、あらゆるシンボルのスコープは可能な限り小さくあるべきです。特定の１箇所やとあるファイル内でのみでしか使われていない関数や定数をグローバル空間に定義するのはやめましょう。スコープを小さく保つことには以下のようなメリットがあります：

- 誤用の可能性が下がる：グローバルなシンボルは誰でも使用できます。実際には特定のケースでのみ使用されるものとして定義したつもりでも、他の人がそれを理解しているとは限りません。今後シンボルの値や挙動が変更された場合、誤用した箇所で不具合が起こる可能性があります。
- IDEなどで補完候補がカオス化しない：グローバル空間に定義したシンボルは、どのファイルでコーディングしていても（たとえ一切関係ない場所でも）補完候補に出てしまいます。スコープを絞れば、文脈に沿った本当の意味での候補が表示される確率が上がります。
- 編集時の影響範囲を特定しやすい：ファイル内のプライベートな関数はそのファイル内でしか使用されません。関数内のコンパイル時定数は関数内からしか参照できません。スコープが小さければシンボルを編集した時の影響範囲も小さくなり、またその把握も容易です。

#### 可能な限りプライベートなシンボルとして定義する

ファイル外に公開する必要の無いシンボルは必ずプライベートなシンボルとして定義してください。クラス内のメンバ変数やメソッドなど、トップレベル以外のシンボルについても同様です。

また、プライベートクラス内のシンボルについても、ファイル外に公開する必要が無い場合はプライベートにしてください。これによりLinterが未使用のシンボルを特定できるようになります。同じファイル内であればクラス外からもプライベートなメソッドなどにアクセスできるため、そのようなケースでもプライベートにすること。

### 関連するものはできるだけ近くに置く

不必要にファイルを分割するのはやめましょう。関連するシンボルが複数ファイルやディレクトリに分散しているより、一つのファイル内にまとまっている方が全体像を把握が簡単です。例えばそのモジュール（ファイル）を代表するpublicなクラスがあり、またその内部で使用される補助的な関数やクラスがあるとします。この場合、補助関数や補助クラスは同一ファイル内にプライベートなシンボルとして定義されるべきです。クラスが複数あるからといって、１クラス１ファイルにこだわる必要はありません。

別のセクションでも言及しましたが、スコープはできるだけ小さくすべきです。そして複数ファイルに分割するということはスコープを広げることにもなります。スコープ最小化の原則を守れば、このセクションのルールは自然と守られるはずです。ただし、モジュール内でさらにスコープを分割したい場合はその限りではありません。そのような場合は複数ファイルに分割することで保守性が上がるため、ケースバイケースで柔軟に対処すること。

## 開発ワークフロー

意味のある単位（Gitのコミットとして適切な粒度）でファイルの編集・作成を区切り、以下のワークフローを必ず実施すること：

1. フォーマットと静的解析
2. テストの実施
3. コミット

### フォーマットと静的解析

ファイルの編集に一区切りついたら、プロジェクトルートで必ずフォーマットと静的解析を実行すること。1ファイル編集するごとに実行するのは非効率なので、まとまりのある編集が終わったタイミングで1度実行すれば良い。

```console
make tidyup
```

静的解析で報告されたエラーやワーニングはできる限り解消すること。エラーの内容が不明確な場合は、`make tidyup`が出力するリントエラー名を元にエラーに関するより詳細な情報や修正方法を`www.dart.dev/tools/linter-rules/`で確認できます。例えば`always_declare_return_types`というエラーの詳細は次のページで確認できます：

```url
https://dart.dev/tools/linter-rules/always_declare_return_types
```

ただし、編集箇所と無関係だと思われるワーニングや、ユーザーから無視すべきと指示されたエラーは放置して良い。また、エラーの解消に大幅な修正が必要になりそうな場合は一度手を止め、ユーザーに相談すること。無理に全てのエラーやワーニングを解消する必要はない。また、場合によっては`ignore`を使用し、例外的に一部分だけエラーを無視することが適切かもしれません。しかし、多用は厳禁です。

```dart
// ignore: always_declare_return_types
add(int a, int b) => a + b;
```

### テストの実施

静的解析のエラーを解消したら、必ずテストを実行すること。テストが失敗した場合は該当箇所のコードを修正し、再度「フォーマットと静的解析」から開始すること。テストが成功するまでこのサイクルを繰り返す。

```console
make test
```

テストは期待される動作（仕様）を表現しているため、原則としてテストコードは変更してはならない。実装に合わせてテストを変更するのは本末転倒である。テストが失敗した場合は、まず実装側の問題を疑い修正すること。ただし、テスト自体に明らかな不具合がある場合（間違ったアサーション、タイポなど）、仕様変更により期待される動作が変わった場合、テストの前提条件やセットアップが不適切な場合は、テストコードを修正してよい。また、判断に迷った場合は一度手を止め、ユーザーや他の開発者に相談すること。「テストを通すため」だけの理由でテストコードを変更してはならない。

### コミット

静的解析とテストの両方が成功したら、変更をコミットすること。この時、メッセージは何を変更したかを1行で簡潔に表現すること。詳細な背景や理由がある場合は2つ目の`-m`オプションでdescriptionを追加してよいが、コードを見て変更内容が明らかな場合は説明不要である。

良い例：

```console
git commit -m "Add validation to email input field"
git commit -m "Refactor user repository" -m "Extract common database operations to reduce code duplication"
```

悪い例：

```console
git commit -m "Fix bug"  # 何のバグかわからない
git commit -m "Add validation to email input field to prevent users from entering invalid email addresses which could cause issues later"  # 1行が長すぎる
```

## パッケージの追加

パッケージを新規追加する際、直接`pubspec.yaml`を編集しないこと。必ず、以下のようにコマンド経由で追加すること。

```console
# 通常のパッケージを追加
make addpkg PACKAGES='pkg1 pkg2'

# 開発時にしか使用しないパッケージを追加（build_runnerなど）
make addpkg-dev PACKAGES='pkg1 pkg2'
```
